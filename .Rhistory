plot(rotate(x, 55))
plot(rotate(x, 65))
plot(rotate(x, 0))
plot(rotate(x, 50))
plot(rotate(x, 0))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x * rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 1))
x = iris[,c(1,3)]
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x * rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 1))
plot(rotate(x, 45))
plot(rotate(x, 30))
plot(rotate(x, 15))
plot(rotate(x, 0))
plot(rotate(x, 1))
plot(rotate(x, 2))
plot(rotate(x, 3))
plot(rotate(x, 15))
plot(rotate(x, 25))
plot(rotate(x, 35))
plot(rotate(x, 45))
plot(rotate(x, 55))
plot(rotate(x, 65))
plot(rotate(x, 75))
plot(rotate(x, 85))
plot(rotate(x, 95))
plot(rotate(x, 120))
plot(rotate(x, 121))
plot(rotate(x, 122))
plot(rotate(x, 150))
plot(rotate(x, 180))
plot(rotate(x, 360))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 1))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 10))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 20))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 30))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 40))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 50))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 66))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 77))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 88))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 90))
x = as.matrix(iris[,c(1,3)])
rotate = function(x, degree){
rot = matrix(c(cos(deg2rad(degree)),sin(deg2rad(degree)),-sin(deg2rad(degree)),cos(deg2rad(degree))),2,2)
return (x %*% rot)
}
deg2rad = function(deg) {(deg * pi) / (180)}
plot(rotate(x, 0))
matrix(1, 2, 2)
solve(matrix(1, 2, 2))
solve(matrix(2, 2, 2))
solve(matrix(2, 2, 1))
a = matrix(c(1,2,2,1), 2, 2)
a
solve(a)
solve(1)
solve(10)
solve(100)
a = matrix(0, 2, 2)
a
b = a
c = cbind(a,b)
c
d[[1]] = 2
m = function(mu, v, M){
det(M %*% Exp(mu, v))
}
kernel = function(x1, x2, sigma){
summ = 0
for(i in 1:D){
summ = summ + (x1 - x2)^2
}
return ( exp(-sum / ((2 * sigma)^2) ))
}
Exp = function(){
}
Log = function(){
}
library('MASS')
x = as.matrix(iris[,c(1,3)]) #150 x 2
mu = mean(x) # Média estimada
cov = cov(x) # Matriz de covariância estimada
t = 0
S = dim(x)[1] # Numero de observações
D = dim(x)[2] # Numero of atributos
Z = sqrt(((2*pi)^D) * det(cov)) # Constante de normalização da distribuição normal Euclidiana
# Equação 7
sigma = 0.5
p = 0.01
M = list()
w = matrix(0, S, S)
M
w
for(i in 1:S){
for(j in 1:S){
w[i, j] = kernel(x[i,], x[j,], sigma)
}
}
i = 1
j = 1
kernel(x[i,], x[j,], sigma)
dim(x)
kernel = function(x1, x2, sigma){
summ = 0
for(i in 1:dim(x1)[2]){
summ = summ + (x1 - x2)^2
}
return ( exp(-sum / ((2 * sigma)^2) ))
}
kernel(x[i,], x[j,], sigma)
dim(x[i,])
x
i
x[i,]
x[2,]
length(x[1,])
length(x[1,]
kernel = function(x1, x2, sigma){
summ = 0
for(i in 1:length(x1)){
summ = summ + (x1 - x2)^2
}
return ( exp(-sum / ((2 * sigma)^2) ))
})
kernel = function(x1, x2, sigma){
summ = 0
for(i in 1:length(x1)){
summ = summ + (x1 - x2)^2
}
return ( exp(-sum / ((2 * sigma)^2) ))
}
kernel(x[i,], x[j,], sigma)
x1 = x[1,]
x2 = x[2,]
sigma = 2
summ = 0
kernel = function(x1, x2, sigma){
summ = 0
for(d in 1:length(x1)){
summ = summ + (x1[d] - x2[d])^2
}
return ( exp(-sum / ((2 * sigma)^2) ))
}
kernel(x[i,], x[j,], sigma)
kernel = function(x1, x2, sigma){
summ = 0
for(d in 1:length(x1)){
summ = summ + (x1[d] - x2[d])^2
}
return ( exp(-summ / ((2 * sigma)^2) ))
}
kernel(x[i,], x[j,], sigma)
kernel(x[i,], x[2,], sigma)
kernel(x[2,], x[2,], sigma)
kernel(x[2,], x[1,], sigma)
sigma = 0.5
p = 0.01
M = list()
w = matrix(0, S, S)
for(i in 1:S){
for(j in 1:S){
w[i, j] = kernel(x[i,], x[j,], sigma)
}
}
w
dim(w)
for(i in 1:S){
tempM = matrix(0, D, D)
for(d in 1:D){
for(j in 1:S){
tempM[d, d] = tempM[d, d] + (w[i, j] * ((x[i,d] - x[j,d])^2) + p)
}
}
M[[i]] = tempM
}
M
c(0,0)
rep(0, D)
v = mvrnorm(S, rep(0, D), cov)
v
plot(v)
plot(x)
plot(v)
plot(x)
plot(v)
mu
v
p = 0.01
M = list()
for(i in 1:S){
tempM = matrix(0, D, D)
for(d in 1:D){
for(j in 1:S){
tempM[d, d] = tempM[d, d] + (w[i, j] * ((x[i,d] - x[j,d])^2) + p)
}
}
M[[i]] = solve(tempM)
}
M
a
a[1,1] = 2
a[2,2] = 2
a
solve(a)
solve(2)
library('MASS')
x = as.matrix(iris[,c(1,3)]) #150 x 2
mu = mean(x) # Média estimada
cov = cov(x) # Matriz de covariância estimada
t = 0
S = dim(x)[1] # Numero de observações
D = dim(x)[2] # Numero of atributos
Z = sqrt(((2*pi)^D) * det(cov)) # Constante de normalização da distribuição normal Euclidiana
# Equação 7
sigma = 0.5
w = matrix(0, S, S)
for(i in 1:S){
for(j in 1:S){
w[i, j] = kernel(x[i,], x[j,], sigma)
}
}
d
a
cov
-cov
ginv(cov)
solve(cov)
n
v
v = mvrnorm(S, rep(0, D), cov) # Normal com média 0 e matriz de covariância estimada
v
2 / 2 * 2
2 / (2 * 2)
bigint <- integer(2^32 / 4)
bigint
bigint
path = 'C:/Projects/case_celpe/celpe_case'
setwd(path)
source('utils.r')
# Lendo a base de treinamento
dataset = read.table('Train.csv', header=T, sep=';', stringsAsFactors = FALSE)
# Pre processando e salvando em outro arquivo
dataset = preProcessDataset(dataset)
write.table(as.data.frame(dataset), file = 'processed_train.csv', sep=';', row.names = FALSE)
dataset = read.table('processed_train.csv', header=T, sep=';')
dataset[,'TARGET']
dataset[, 'TARGET'] = as.factor(dataset[, 'TARGET'])
dataset[,'TARGET']
dataset1 = splitDataset(dataset, 0.7)
dataset1[,'TARGET']
dataset1$train[,'TARGET']
dataset2 = selectBestFeatures(dataset)
dataset2[, 'TARGET'] = dataset[, 'TARGET']
dataset2 = splitDataset(dataset2, 0.7)
dataset2$train[,'TARGET']
trainLabels = as.numeric(dataset1$trainLabels)
trainLabels
dataset1$trainLabels
bst= xgboost(data = data.matrix(dataset$train_NO_TGT, rownames.force = NA), label = dataset1$trainLabels, max_depth = 2, eta = 1, nthread = 2, nrounds = 2, objective = "binary:logistic")
library('xgboost')
bst= xgboost(data = data.matrix(dataset$train_NO_TGT, rownames.force = NA), label = dataset1$trainLabels, max_depth = 2, eta = 1, nthread = 2, nrounds = 2, objective = "binary:logistic")
bst= xgboost(data = data.matrix(dataset1$train_NO_TGT, rownames.force = NA), label = dataset1$trainLabels, max_depth = 2, eta = 1, nthread = 2, nrounds = 2, objective = "binary:logistic")
dataset1$trainLabels
dataset = read.table('processed_train.csv', header=T, sep=';')
# Dividindo a base em 70% treinamento e 30% teste
dataset1 = splitDataset(dataset, 0.7)
# Selecionando melhores features com regressão logística
dataset2 = selectBestFeatures(dataset)
dataset2[, 'TARGET'] = dataset[, 'TARGET']
dataset2 = splitDataset(dataset2, 0.7)
# Decision Tree
dtTest = function(dataset){
dt_model = rpart(dataset$trainLabels ~ ., data = dataset$train_NO_TGT)
dt_pred = predict(dt_model, newdata = dataset$test_NO_TGT)
return (roc.curve(dataset$testLabels, dt_pred[,2], plotit = F))
}
# Balanced Deep Learning
deepTest = function(dataset){
# Transformando alvo em fator, para o modelo entender que a variável é binária e não numérica
dataset$train[, 'TARGET'] = as.factor(dataset$train[, 'TARGET'])
dataset$test[, 'TARGET'] = as.factor(dataset$test[, 'TARGET'])
dl_model = h2o.deeplearning(y='TARGET', training_frame=as.h2o(dataset$train), validation_frame=as.h2o(dataset$test),
hidden=c(50,50), epochs=0.1, activation='Tanh',
score_training_samples=1000,
score_validation_samples=1000,
balance_classes=TRUE,
score_validation_sampling='Stratified')
return (dl_model)
}
# Extreme Gradient Boosting
xgboostTest = function(dataset){
# Alvo precisa ser 0 e 1 e numérico
trainLabels = as.numeric(dataset$trainLabels)
trainLabels[which(trainLabels == 2)] = 0
bst= xgboost(data = data.matrix(dataset$train_NO_TGT, rownames.force = NA), label = trainLabels, max_depth = 2, eta = 1, nthread = 2, nrounds = 2, objective = "binary:logistic")
pred = predict(bst, data.matrix(dataset$test_NO_TGT, rownames.force = NA))
#return (pred)
return( roc.curve(dataset$testLabels, pred, plotit = F) )
}
dtTest(dataset1)
dtTest(dataset2)
library('rpart')
dtTest(dataset1)
dtTest(dataset2)
library('ROSE')
dtTest(dataset1)
dtTest(dataset2)
dtTest = function(dataset){
dt_model = rpart(dataset$trainLabels ~ ., data = dataset$train_NO_TGT)
dt_pred = predict(dt_model, newdata = dataset$test_NO_TGT)
return (roc.curve(dataset$testLabels, dt_pred, plotit = F))
}
dtTest(dataset1)
dtTest(dataset2)
xgboostTest(dataset1)
xgboostTest(dataset2)
pacman::p_load('h2o')
h2o.init(nthreads=-1)
deepTest = function(dataset){
# Transformando alvo em fator, para o modelo entender que a variável é binária e não numérica
dataset$train[, 'TARGET'] = as.factor(dataset$train[, 'TARGET'])
dataset$test[, 'TARGET'] = as.factor(dataset$test[, 'TARGET'])
dl_model = h2o.deeplearning(y='TARGET', training_frame=as.h2o(dataset$train), validation_frame=as.h2o(dataset$test),
hidden=c(50,50), epochs=0.1, activation='Tanh',
score_training_samples=1000,
score_validation_samples=1000,
balance_classes=TRUE,
score_validation_sampling='Stratified')
return (dl_model)
}
dl_model1 = deepTest(dataset1)
dl_model2 = deepTest(dataset2)
dl_model1
dl_model2
xgboostTest = function(dataset){
# Alvo precisa ser 0 e 1 e numérico
trainLabels = as.numeric(dataset$trainLabels)
trainLabels[which(trainLabels == 2)] = 0
bst= xgboost(data = data.matrix(dataset$train_NO_TGT, rownames.force = NA), label = trainLabels, objective = "binary:logistic")
pred = predict(bst, data.matrix(dataset$test_NO_TGT, rownames.force = NA))
#return (pred)
return( roc.curve(dataset$testLabels, pred, plotit = F) )
}
xgboostTest(dataset1)
xgboostTest(dataset2)
?xgboost
xgboostTest = function(dataset){
# Alvo precisa ser 0 e 1 e numérico
trainLabels = as.numeric(dataset$trainLabels)
trainLabels[which(trainLabels == 2)] = 0
bst= xgboost(data = data.matrix(dataset$train_NO_TGT, rownames.force = NA), label = trainLabels, nrounds = 10, objective = "binary:logistic")
pred = predict(bst, data.matrix(dataset$test_NO_TGT, rownames.force = NA))
#return (pred)
return( roc.curve(dataset$testLabels, pred, plotit = F) )
}
xgboostTest(dataset1)
xgboostTest(dataset2)
xgboostTest = function(dataset){
# Alvo precisa ser 0 e 1 e numérico
trainLabels = as.numeric(dataset$trainLabels)
trainLabels[which(trainLabels == 2)] = 0
bst= xgboost(data = data.matrix(dataset$train_NO_TGT, rownames.force = NA), label = trainLabels, nrounds = 100, objective = "binary:logistic")
pred = predict(bst, data.matrix(dataset$test_NO_TGT, rownames.force = NA))
#return (pred)
return( roc.curve(dataset$testLabels, pred, plotit = F) )
}
xgboostTest(dataset1)
xgboostTest(dataset2)
xgboostTest = function(dataset){
# Alvo precisa ser 0 e 1 e numérico
trainLabels = as.numeric(dataset$trainLabels)
trainLabels[which(trainLabels == 2)] = 0
bst= xgboost(data = data.matrix(dataset$train_NO_TGT, rownames.force = NA), label = trainLabels, nrounds = 50, objective = "binary:logistic")
pred = predict(bst, data.matrix(dataset$test_NO_TGT, rownames.force = NA))
#return (pred)
return( roc.curve(dataset$testLabels, pred, plotit = F) )
}
xgboostTest(dataset1)
xgboostTest(dataset2)
dl_model1
deepTest = function(dataset){
# Transformando alvo em fator, para o modelo entender que a variável é binária e não numérica
dataset$train[, 'TARGET'] = as.factor(dataset$train[, 'TARGET'])
dataset$test[, 'TARGET'] = as.factor(dataset$test[, 'TARGET'])
dl_model = h2o.deeplearning(y='TARGET', training_frame=as.h2o(dataset$train), validation_frame=as.h2o(dataset$test),
hidden=c(100, 100), epochs=5, activation='Tanh',
score_training_samples=0,
score_validation_samples=0,
balance_classes=TRUE,
score_validation_sampling='Stratified')
return (dl_model)
}
dl_model1 = deepTest(dataset1)
dl_model1
dl_model2= deepTest(dataset2)
dl_model2
xgboostTest(dataset1)
xgboostTest(dataset2)
dtTest(dataset1)
dtTest(dataset2)
deepTest = function(dataset){
# Transformando alvo em fator, para o modelo entender que a variável é binária e não numérica
dataset$train[, 'TARGET'] = as.factor(dataset$train[, 'TARGET'])
dataset$test[, 'TARGET'] = as.factor(dataset$test[, 'TARGET'])
dl_model = h2o.deeplearning(y='TARGET', training_frame=as.h2o(dataset$train), validation_frame=as.h2o(dataset$test),
hidden=c(100, 100), epochs=5, activation='Tanh',
score_training_samples=0,
score_validation_samples=0,
balance_classes=TRUE)
return (dl_model)
}
dl_model1 = deepTest(dataset1)
dl_model1
deepTest = function(dataset){
# Transformando alvo em fator, para o modelo entender que a variável é binária e não numérica
dataset$train[, 'TARGET'] = as.factor(dataset$train[, 'TARGET'])
dataset$test[, 'TARGET'] = as.factor(dataset$test[, 'TARGET'])
dl_model = h2o.deeplearning(y='TARGET', training_frame=as.h2o(dataset$train), validation_frame=as.h2o(dataset$test),
hidden=c(100, 100), epochs=10, activation='Tanh',
score_training_samples=0,
score_validation_samples=0,
balance_classes=TRUE)
return (dl_model)
}
dl_model1 = deepTest(dataset1)
dl_model1
deepTest = function(dataset){
# Transformando alvo em fator, para o modelo entender que a variável é binária e não numérica
dataset$train[, 'TARGET'] = as.factor(dataset$train[, 'TARGET'])
dataset$test[, 'TARGET'] = as.factor(dataset$test[, 'TARGET'])
dl_model = h2o.deeplearning(y='TARGET', training_frame=as.h2o(dataset$train), validation_frame=as.h2o(dataset$test),
hidden=c(100, 100), epochs=5, activation='Tanh',
score_training_samples=1000,
score_validation_samples=1000,
balance_classes=TRUE)
return (dl_model)
}
dl_model1 = deepTest(dataset1)
dl_model1
auc_dt = dtTest(dataset)
deep_model = deepTest(dataset)
auc_xgboost = xgboostTest(dataset)
